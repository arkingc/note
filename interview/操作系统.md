* **一.理论**
    - **1.进程与线程**
        - 1）进行间通信的方式？([管道](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#31-%E7%AE%A1%E9%81%93)、[消息](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#32-%E6%B6%88%E6%81%AF)、[共享内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#33-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)、[信号量](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#12-%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81)、[信号](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#35-%E4%BF%A1%E5%8F%B7)、套接字)  
        >管道：是一个环形缓冲区，两个进程可以对管道进行读和写操作。匿名管道只能在父子进程间通信， 命名管道可以在不相关的进程间使用。  
        >消息队列：独立于读写进程，避免了同步阻塞的问题，读进程可以根据消息的类型有选择的接收。  
        >共享内存：进程共享一个存储区，不需要进程间复制，速度最快。需要使用信号量同步对共享内存的访问。  
        >信号量：是一个非负整数的全局变量，进程可以对信号量进行PV操作来实现对共享内存的保护。  
        >套接字：主要用于不同机器间的进程通信。  
        - 2）[进程和线程的区别联系](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)？(组成、效率、通信、安全性)  
        >资源：进程是资源分配的基本单位，线程不拥有资源，可以访问隶属进程的资源。  
        >调度：线程是调度的基本单位，同一进程的线程间切换不会引起进程切换。  
        >系统开销：创建或销毁进程时，需要分配资源，开销大于创建或销毁线程。线程切换只需要保存少量寄存器的状态，开销也小于进程切换。  
        >通信：同一进程的线程间通信可以直接访问进程的资源，不同进程通信需要IPC。  
        - 3）[进程的地址空间布局](https://blog.csdn.net/yusiguyuan/article/details/45155035)
        - 4）程序状态字(PSW)？（一个或一组处理器寄存器，包含有进程的状态信息）
        - 5）进程[创建的步骤](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#21-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%88%E6%AD%A2)？  
        >首先分配进程标识符，然后分配空间，再初始化进程控制块。  
        >Linux为子进程分配空间时运用了写时复制技术，调用fork()后子进程和父进程共享一个地址空间，当父或子进程对共享的地址空间写入时，再复制地址空间，使父子进程拥有各自的地址空间。  
        >进程控制块存储程序计数器、堆栈指针、内存分配状况等信息。  
        - 6）进程[切换的步骤](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#42-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2)？
        - 7）一个程序从开始运行到结束的完整过程  
        >预处理：宏定义替换、头文件包含、删除注释。  
        >编译：词法分析、语法分析，无误后转换成汇编代码。  
        >汇编：将汇编代码转换成二进制机器代码。  
        >链接：将多个目标文件和库文件链接成可执行文件。  
        - 8）[线程分配什么？TCB(线程控制块)?](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
        - 9）[线程共享进程的什么？不共享什么？CPU共享吗？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)  
        >共享：地址空间、全局变量、打开的文件描述符。  
        >不共享：程序计数器、寄存器、堆栈、状态。  
        - 10）怎样保证一个CPU只有一个线程运行？（[CPU核数与多线程](https://blog.csdn.net/qq_33530388/article/details/62448212)）
        - 11）[线程有什么状态？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#2%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81)
        - 12）线程池的了解、优点、调度处理方式和保护任务队列的方式？
        - 13）[怎么回收线程？](../操作系统/UNIX环境高级编程.md#2pthread_join函数)
        - 14）进程->线程->协程[——知乎阿猫](https://www.zhihu.com/question/20511233)（本质好像是[用户态线程](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB)，线程与协程最大的区别在是否依赖CPU时钟发出的中断来调度，协程的调度完全由用户控制）
        - 15）[线程与协程的区别](http://www.jianshu.com/p/d058a0fd4ac8)
        - 16）[守护进程、僵尸进程、孤儿进程？](http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/)（守护进程运行在后台，独立于控制终端，周期性执行某种任务，父进程为init，一般系统启动时运行；僵尸进程会占据PID等系统资源，可以通过kill其父进程，转交给init周期性调用wait操作清理）
        - 17）[进程调度方法详细介绍](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)（FCFS、轮转、SPN、SRT、HRRN、反馈法）  
        >批处理系统：没有太多的用户操作，调度目标是保证高吞吐量和少的周转时间。  
        >>先来先服务：按照请求的顺序进行调度，有利于长作业，不利于短作业。  
        >>短作业优先：按估计运行时间最短的顺序进行调度，长作业可能会饿死。  
        >>最短剩余时间优先:需要提前知道程序执行的时间。  
        
        >交互式系统：有大量用户操作，调度目标是快的响应时间。  
        >>时间片轮转：按先来先服务的顺序将进程排成一个队列，队列头的进程先执行一个时间片，执行完后计时器发出时钟中断，该进程便被停止，加入到队列末尾，同时下一个进程再开始执行一个时间片。时间片选择的短会造成进程频繁切换，时间片长会导致响应时间变慢。  
        >>优先级调度：将所有进程按优先级从高到低的顺序执行。为防止低优先级的进程一直得不到执行，会随时间增加或降低等待进程的优先级。  
        >>多级队列：设置多个队列，每个队列上的进程可执行的时间片递增，如1,2,4,8...进程在第一个队列没执行完，就移到下一个队列。可以减少进程交换的次数。  
        - 18）[中断、陷阱和系统调用](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#42-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2)（异常和[中断](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E4%B8%AD%E6%96%AD)的区别？）
    - **2.并发**
        - 1）[什么是条件变量？信号量？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#12-%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81)  
        >条件变量：使线程阻塞于共享变量的某个状态，并在状态改变时被唤醒。  
        >信号量：是一个非负整数，可在其上进行PV操作：  
        >>P:若信号量值大于0，则减一并继续，若为0，则挂起进程。  
        >>V:将信号量加一，若有进程阻塞在该信号量上，则唤醒该进程，使其完成P操作，并返回。  
        - 2）[死锁条件](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#21-%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6)，解决死锁的方法？（[死锁预防](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2)、[死锁避免](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#23-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D)、[死锁检测](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#24-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B)）  
        >死锁条件：  
        >>互斥：一个资源要么被某个进程占有，要么就是可用的。  
        >>占有和等待：进程可以在占有某个资源的情况下请求新的资源。  
        >>不可抢占：已经被某个进程占有的资源不可被其他进程强制抢占。  
        >>环路等待：进程组成一个环路，每个进程都在请求下一个进程占有的资源。  
        >死锁预防：
        >>破坏互斥：进程只能按顺序请求资源。  
        - 3）互斥和同步？（互斥是对资源独占访问，同步是在互斥基础上通过其它机制实现对资源有序访问）
        - 4）互斥量和信号量的区别？（一个互斥一个同步、值的区别、加锁解锁的线程）
        - 5）自旋锁和互斥量的区别？（失败后的表现，一个忙等一个睡眠）
    - **3.内存管理**
        - 1）分区（进程整个被载入内存中连续区域，[分区中的地址转换](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#24-%E5%88%86%E5%8C%BA%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
            + [固定分区](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#21-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA)（分区大小相等、分区大小不等，内部碎片，活动进程数固定）
            + [动态分区](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA)（需要时才分区，外部碎片,[放置算法](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA)：最佳、首次、下次适配）
        - 2）[伙伴算法](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#23-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F)
        - 3）[分页](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E5%88%86%E9%A1%B5)（一个进程可以占据多个页，不要求连续，仅最后一页存在内部碎片；[分页中的地址转换](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#31-%E5%88%86%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
        - 4）[分段](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#4%E5%88%86%E6%AE%B5)（类似于动态分区，区别是进程可以占据多个不连续的区域，外部碎片，[分段中的地址转换](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#41-%E5%88%86%E6%AE%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
        - 5）[缓冲区溢出是什么？会造成什么危害呢？出现原因是什么？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#51-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA)
        - 6）分区、分页和分段都要求程序整个载入内存（分区要求连续，分页和分段不要求连续）
        - 7）[虚拟内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)（内存管理单元(MMU)：CPU中的一个模块，可以将虚拟地址转换成实际物理地址）
            + 虚拟内存的作用？（程序可以比实际物理内存更大、程序不必完全载入内存即可运行，因此活动进程数更多、系统抖动？）  
            >程序拥有自己的地址空间，地址空间被分割成页，一部分页被载入到物理内存中，当程序执行时访问到不在物理内存中的页时，引发缺页中断，操作系统把引发中断的地址空间的页载入内存，重新执行指令。  
            + 基于[分页](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#1-%E5%88%86%E9%A1%B5)的实现（和不使用虚拟内存相比，页表中多了2个位，一位表示页是否修改，一位表示页是否在内存中、[两级分页系统](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#13-%E4%B8%A4%E7%BA%A7%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)）
            + [TLB？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#15-%E8%BD%AC%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%BC%93%E5%86%B2%E5%8C%BAtlb)（加速页表的访问）
            + 基于[分段](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#2-%E5%88%86%E6%AE%B5)的实现（和不使用虚拟内存相比，段表中多了2个位，一位表示段是否修改，一位表示段是否在内存中）
            + 内存保护（分段有助于内存保护，段表中段的长度描述了段的区域，公共代码可以作为一个段被相同程序的多个进程共享）
            + 基于[段页式](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3-%E6%AE%B5%E9%A1%B5%E5%BC%8F)的实现
                * 分段对程序员可见、分页对程序员透明
                * 分段有助于扩展性与内存保护、分页有助于消除外部碎片
            + [页面置换方法详细介绍](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#43-%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5)（OPT、LRU、FIFO、时钟）  
            >OPT：置换下次使用距当前时间最短的页。  
            >LRU：置换上次使用距当前时间最短的页。  
            >NRU：用两个状态位标识R和M，访问到则将R置为1，修改则将M置为1同时R置为0，置换出被修改的脏页面，而不是频繁使用的干净页面。  
            >FIFO：置换最先进入的页面，可能会导致经常使用的页也被置换，增高缺页率。  
            >第二次机会：如果最先进入的页面R为1，则将其放入链表尾端，重新选择链表头部的页面置换。  
            >时钟：用环形链表将页面连接起来，用一个指针指向最老的页面。  
            + [驻留集](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#44-%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86)（分配给每个进程的内存大小）管理
                * 驻留集越小，获得进程越多，缺页越高；驻留集越大，活动进程越小，太多时缺页率无明显变化
                * 分配策略与置换范围（固定分配、可变分配、局部置换、全局置换，不存在固定分配全局置换）
            + [清除（写回）策略](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#45-%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5)
    - **4.I/O与磁盘调度**
        + 1）[DMA？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#5%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%AD%98%E5%8F%96dma)
        + 2）[I/O缓冲？](../操作系统/操作系统.md#1io缓冲)（输入请求发出之前执行输入，输出请求发出一段时间后才执行输出）
        - 3）[磁盘调度算法](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#22-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)（FIFO、优先级、SSTF、SCAN、C-SCAN、N-step-SCAN）
* **二.Linux**
    - **1.进程线程**
        + 1）[C程序的存储空间布局](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#3c%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80)
        + 2）[fork vfork clone](temp/进程线程.md#1forkvforkclone)
        + 3）[Linux性能及调优指南：进程管理](http://blog.jobbole.com/105135/)
        + 4）[Linux守护进程启动方法](http://blog.jobbole.com/98657/)
        + 5）[如何实现守护进程](temp/进程线程.md#1如何实现守护进程)
        + 6）[main函数启动之前](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#11-main%E5%87%BD%E6%95%B0)
        + 7）[exit、\_exit、\_Exit](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BB%88%E6%AD%A2)
        + 8）[线程数量的限制](temp/进程线程.md#1线程数量的限制)
        + 9）[进程数量的限制](temp/进程线程.md#2进程数量的限制)
        + 10）[信号](temp/信号.md#1信号)
        + 11）线程终止的方法？
            * [pthread_exit](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5pthread_exit%E5%87%BD%E6%95%B0)（主线程调用了`pthread_exit`对其它线程有什么影响？）
            * 线程执行的函数`return`
            * 被同一进程的其它线程调用[pthread_cancel取消线程](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#7pthread_cancel%E5%87%BD%E6%95%B0)
            * 进程main函数`return`或任何线程调用了`exit`、`_Exit`、`exit`
        + 12）[线程与信号](temp/信号.md#2线程与信号)
        + 13）[正确使用waitpid处理终止的子进程](https://github.com/arkingc/note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71.md#12-%E4%BD%BF%E7%94%A8waitpid%E7%89%88sig_chld%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E5%AD%90%E8%BF%9B%E7%A8%8Bsigchld%E4%BF%A1%E5%8F%B7)
    - **2.并发**
        + 1）[Linux上分析死锁的简单方法](http://blog.jobbole.com/109743/)
        + 2）进程间通信的主要方式（[管道](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#1%E7%AE%A1%E9%81%93)、[FIFO](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#3fifo)、信号、[消息队列](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)、[共享内存](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#7%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8)、[信号量](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#8posix%E4%BF%A1%E5%8F%B7%E9%87%8F)、套接字）
        + 3）[线程间同步的主要方式](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#2%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5)（互斥量、读写锁、条件变量、自旋锁、屏障）
        + 4）[Linux内核同步机制](http://blog.jobbole.com/91784/)
    - **3.文件系统**
        + 1）[Linux中的文件类型](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#2%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B)
        + 2）Linux有哪几种设备？（字符设备与块设备，[mknod系统调用](https://blog.csdn.net/lqp276/article/details/53502992)用来创建设备文件）
        + 3）[如何唯一标识一个设备？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#13%E8%AE%BE%E5%A4%87%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6)（主设备号和次设备号）
        + 4）[文件描述符的个数](https://blog.csdn.net/yetyongjin/article/details/7476860)
    - **4.I/O**
        + 1）5种I/O模型（[总览](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#%E5%85%AB%E9%AB%98%E7%BA%A7io)）
        + 2）[如何理解阻塞非阻塞与同步异步的区别？](temp/IO.md#2如何理解阻塞非阻塞与同步异步的区别)
        + 3）文件读写使用的系统调用：[open](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#21-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6)、[close](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#23-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6)、[lseek](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#24-%E5%AE%9A%E4%BD%8D%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE)、[read](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#25-%E6%96%87%E4%BB%B6%E8%AF%BB)、[write](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#26-%E6%96%87%E4%BB%B6%E5%86%99)
        + 4）[sync、fsync、fdatasync？](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#5%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5)
        + 5）[文件内存映射mmap](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.md#6%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84io)（如何使用mmap为文件添加数据？）
    - **5.内存管理**
        + 1）[Linux内存模型](https://www.ibm.com/developerworks/cn/linux/l-memmod/)（内核）
        + 2）[内核内存分配vmalloc与kmalloc](temp/内存管理.md#1内核内存分配)
        + 3）[Linux内核伙伴系统](temp/内存管理.md#二伙伴系统)
        + 4）[slab分配器](temp/内存管理.md#三slab分配器)
        + 5）[Linux内核空间和用户空间是如何划分的？](temp/内存管理.md#1linux内核空间与用户空间是如何划分的)
    - **6.其它**
        + 1）[Linux系统调用](http://gityuan.com/2016/05/21/syscall/)
        + 2）[Linux如何实现系统调用？](temp/系统调用.md#1linux通过什么方式实现系统调用)
        + 3）[Linux中的软中断和工作队列的作用？](temp/进程线程.md#1linux中的软中断和工作队列的作用)
        + 4）[Linux系统中的动态库和静态库](http://blog.jobbole.com/107977/)
        + 5）[Linux Core Dump理解](http://blog.jobbole.com/107760/)
        + 6）[Linux Shell管道命令与重定向命令的区别](http://blog.jobbole.com/93132/)
        + 7）[ioctl函数理解](http://www.cnblogs.com/li-hao/archive/2011/12/22/2297687.html)

